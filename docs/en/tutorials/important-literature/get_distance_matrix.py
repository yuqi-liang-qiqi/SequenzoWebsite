"""
@Author  : Xinyi Li 李欣怡, Yuqi Liang 梁彧祺
@File    : get_distance_matrix.py
@Time    : 2024/11/10 19:55
@Desc    : Computes pairwise dissimilarities between sequences or dissimilarity from a reference sequence.
            Several dissimilarity measures can be chosen,
            including optimal matching (OM) and many of its variants, distance based on the count of common attributes,
            and distances between state distributions within sequences.

        :params
            seqdata        : State sequence object of class stslist
            method         : String.The dissimilarity measure to use.
                            It can be "OM", "OMloc", "OMslen", "OMspell", "OMspellNew", "OMtspell", "OMstran", "HAM", "DHD",
                            "CHI2", "EUCLID", "LCS", "LCP", "RLCP", "LCPspell", "RLCPspell",
                            "NMS", "NMSMST", "SVRspell", or "TWED".
            refseq         : Default: NULL. The baseline sequence to compute the distances from.
                            (1)When an integer, the index of a sequence in seqdata or 0 for the most frequent sequence.
                            (2)When a state sequence object, it must contain a single sequence and have the same alphabet as seqdata.
                            (3)When a list, it must be a list of two sets of indexes of seqdata rows.
            norm           : Default: "none". The normalization to use when method is one of
                            {"OM", "OMloc", "OMslen", "OMspell", "OMspellNew", "OMstran", "TWED", "HAM", "DHD",
                            "LCS", "LCP", "RLCP", "LCPspell", "RLCPspell", "CHI2", "EUCLID"}.
                            (1)It can be "none", "auto", or,
                                except for "CHI2" and "EUCLID", "maxlength", "gmean", "maxdist", "YujianBo", or "ElzingaStuder".
                            (2)"auto" is equivalent to
                                1) "maxlength" when method is one of "OM", "HAM", or "DHD",
                                2) "gmean" when method is one of "LCS", "LCP", "RLCP", "LCPmst", "RLCPmst", "LCPprod", "RLCPprod",
                                3) "maxdist" when method is one of "LCPspell", "RLCPspell",
                                4) YujianBo when method is one of "OMloc", "OMslen", "OMspell", "OMspellNew", "OMstran", "TWED".
                            (3)"ElzingaStuder" applies a theoretical normalization following Elzinga & Studer (2019),
                                dividing distances by their theoretical maxima to ensure comparability across measures.
                                Requires a reference object (see normalization_reference_index parameter for details).
                                Default: uses refseq if provided as single sequence index, otherwise uses index 0.
                            See developer/NORM_GUIDE.md for formulas and pitfalls (e.g. LCPspell/RLCPspell must use maxdist, not gmean).
            indel          : Insertion/deletion  cost(s).
                            Applies when method is one of "OM", "OMslen", "OMspell", "OMspellNew", or "OMstran".
                            (1)The single state-independent insertion/deletion cost when a double.
                            (2)The state-dependent insertion/deletion costs when a vector of doubles.
                                The vector should contain an indel cost by state in the order of the alphabet.
                            (3)When "auto", the indel is set as max(sm)/2 when sm is a matrix
                                and is computed by means of seqcost when sm is a string specifying a cost method.
            sm             : Substitution costs. Default: NULL.
                            (1)The substitution-cost matrix when a matrix
                                and method is one of "OM", "OMloc", "OMslen", "OMspell", "OMspellNew", "OMstran", "HAM", or "TWED".
                            (2)The series of the substitution-cost matrices when an array and method = "DHD".
                                They are grouped in a 3-dimensional array with the third index referring to the position in the sequence.
                            (3)One of the strings "CONSTANT", "INDELS", "INDELSLOG", "TRATE", "FUTURE", or "FEATURES".
                                Designates a seqcost method to build sm. "CONSTANT" is not relevant for "DHD".
                                For "FEATURES", pass state_features (and optionally feature_weights, feature_type) via kwargs.
                                OMtspell is selected automatically when method="OMspell" and tokdep_coeff is provided (e.g. in opts or kwargs).
                            sm is mandatory when method is one of "OM", "OMloc", "OMslen", "OMspell", "OMspellNew", "OMstran", or "TWED".
                            sm is autogenerated when method is one of "HAM" or "DHD" and sm = NULL.
            full.matrix    : Default: TRUE. When refseq = NULL, if TRUE, the full distance matrix is returned,
                            if FALSE, an object of class dist is returned,
                            that is, a vector containing only values from the lower triangle of the distance matrix.
                            Objects of class dist are smaller and can be passed directly as arguments to most clustering functions.
            matrix_display : Default: "full". Only used when the result is a full DataFrame (full_matrix=True, refseq=None).
                            How to display the symmetric distance matrix:
                            - "full": show entire matrix (default).
                            - "upper": show only the upper triangle (including diagonal); masked cells are shown as empty for a cleaner view.
                            - "lower": show only the lower triangle (including diagonal); masked cells are shown as empty for a cleaner view.
                            When "upper" or "lower", masked cells are stored as empty string so they display blank (not "NaN"). The underlying distances are unchanged.
            tpow           : Default: 1.0.
                            The exponential weight of spell length when method is one of "OMspell", "OMspellNew", "NMSMST", or "SVRspell".
            expcost        : Default: 0.5. The cost of spell length transformation when method = "OMloc", "OMspell", "OMspellNew", "LCPspell", or "RLCPspell".
                            It must be positive. The exact interpretation is distance-dependent.
            weighted       : Default: TRUE. When method is "CHI2" or when sm is a string (method),
                            should the distributions of the states account for the sequence weights in seqdata?
            check.max.size : Logical. Should seqdist stop when maximum allowed number of unique sequences is exceeded?
            normalization_reference_index : int, optional. Only used when norm="ElzingaStuder".
                            Index of the reference object for Elzinga & Studer (2019) normalization.
                            Default behavior: If None and refseq is a single sequence index, uses refseq; 
                            otherwise uses index 0 (first sequence).
                            
                            How to choose the reference object:
                            - Comparing different groups/cohorts: Use empty sequence (if available) or medoid 
                              to ensure fair comparison across groups.
                            - Studying specific patterns: Use the pattern sequence as reference (specify its index).
                            - Quick testing: Use default (index 0) for convenience.
                            
                            Common choices:
                            - Empty sequence: Good for analyzing structural differences regardless of length.
                              If your first sequence is empty, use normalization_reference_index=0.
                            - Medoid: The sequence with minimum total distance to all others. Compute full distance 
                              matrix first, then find the medoid index.
                            - Most frequent sequence: The sequence that appears most often in your data.
                            - Specific template: A theoretically or practically meaningful reference sequence 
                              (e.g., "standard career trajectory").
                            
                            For most cases, using the default (index 0) or empty sequence is sufficient.
"""
import gc
import time
import warnings

from scipy.spatial.distance import pdist, squareform
import numpy as np
import pandas as pd

from sequenzo.define_sequence_data import SequenceData

with_missing_warned = False

def get_distance_matrix(seqdata=None, method=None, refseq=None, norm="none", indel="auto", sm=None, full_matrix=True,
                        tpow=1.0, expcost=0.5, weighted=True, check_max_size=True, matrix_display="full", opts=None, **kwargs):

    from .utils.seqconc import seqconc
    from .utils.seqdss import seqdss
    from .utils.seqdur import seqdur
    from .utils.seqlength import seqlength
    from . import get_substitution_cost_matrix

    # Lazily import the c_code module to avoid circular dependencies during installation
    from .__init__ import _import_c_code
    c_code = _import_c_code()

    gc.collect()                           # garbage collection

    if opts is not None:
        seqdata = opts.get('seqdata')
        method = opts.get('method')
        refseq = opts.get('refseq')
        norm = opts.get('norm') or "none"
        indel = opts.get('indel') or "auto"
        sm = opts.get('sm')
        full_matrix = opts.get('full_matrix') or True
        tpow = opts.get('tpow') or 1.0
        expcost = opts.get('expcost') or 0.5
        weighted = opts.get('weighted') or True
        check_max_size = opts.get('check_max_size') or True
        matrix_display = opts.get('matrix_display') or "full"

    if 'with_missing' in kwargs:
        print("[!] 'with_missing' has been removed and is ignored.")
        print("    Missing values are always included by default, consistent with TraMineR.")

        with_missing_warned = True

    # ======================================
    # Check Arguments With Deprecated Values
    # ======================================
    # the version in 2017
    # check method
    deprecated_methods = ["OMopt", "LCSopt"]
    if method in deprecated_methods:
        print(f"[!] Warning: {method} is deprecated.\n")

        if method == "OMopt":
            method = "OM"
            print(f"[!] 'method' is set to \"OM\" which is equivalent.")
        elif method == "LCSopt":
            method = "LCS"
            print(f"[!] 'method' is set to \"LCS\" which is equivalent.")

    # check norm
    if isinstance(norm, bool):
        norm = "auto" if norm else "none"
        print("[!] Warning: 'norm' has a deprecated value, TRUE changed into 'auto', FALSE into 'none'.\n")

    # ===========================================
    # Check For Arguments That Need To Be Defined
    # ===========================================
    # Check if the method parameter is missing
    if seqdata is None:
        raise ValueError("[!] The 'seqdata' parameter is missing.")
    if method is None:
        raise ValueError("[!] The 'method' parameter is missing.")

    # ====================
    # Check Argument Types
    # ====================
    if not isinstance(seqdata, SequenceData):
        raise ValueError("[!] 'seqdata' must be a state sequence object created with SequenceData")

    nseqs = seqdata.seqdata.shape[0]
    nstates = len(seqdata.states)
    seqs_dlens = np.unique(seqlength(seqdata))

    # check method
    om_methods = ["OM", "OMloc", "OMslen", "OMspell", "OMspellNew", "OMstran", "OMtspell"]
    methods = om_methods + ["HAM", "DHD", "CHI2", "EUCLID", "TWED", "LCS", "LCP", "RLCP", "LCPspell", "RLCPspell", "LCPmst", "RLCPmst", "LCPprod", "RLCPprod", "NMS", "NMSMST", "SVRspell"]

    if method not in methods:
        raise ValueError(f"[!] Invalid 'method': {method}. Expected one of {methods}")

    # check refseq
    if refseq is not None:
        # if list of two sets of indexes, we will compute pairwise distances between the two sets
        if isinstance(refseq, list) and len(refseq) > 1:
            if len(refseq) > 2:
                print("[!] Warning: Only first two elements of the 'refseq' list are used.\n")

            for i, ref in enumerate(refseq[:2]):
                if any(not isinstance(x, int) or x < 0 for x in ref):
                    raise ValueError(
                        "[x] When 'refseq' is a list, it must contain two sets of indexes with positive integer values.")

                if max(ref, default=-1) > nseqs:
                    raise ValueError("[x] Some indexes in 'refseq' are out of range.")

            refseq_type = "sets"

        elif isinstance(refseq, int):
            if refseq < 0 or refseq >= nseqs:
                raise ValueError("[x] 'refseq' index must be in range [0, nseqs-1].")
            refseq_type = "index"

        else:
            raise ValueError("[!] Invalid 'refseq' value.")

    else:
        refseq_type = "none"

    # check for empty sequences
    sdur = seqdur(seqdata)
    emptyseq = np.where(np.isnan(sdur[:, 0]))[0]

    if len(emptyseq) > 0:
        if method == "OMloc":
            raise ValueError(f"[!] Error: empty sequences in method 'OMloc': {emptyseq}.")
        else:
            print(f"[!] Warning: empty sequences {emptyseq}.\n")

    print(f"[>] Processing {nseqs} sequences with {nstates} unique states.")

    # check norm
    norms = ["auto", "none", "maxlength", "gmean", "maxdist", "YujianBo", "ElzingaStuder"]
    if norm not in norms:
        raise ValueError(f"[!] 'norm' should be in {norms}.")
    # CHI2 and EUCLID accept only "auto" or "none" (TraMineR)
    if method in ["CHI2", "EUCLID"] and norm not in ["auto", "none"]:
        raise ValueError(f"[!] For {method}, norm can only be one of 'none' or 'auto'.")
    # ElzingaStuder normalization requires full distance matrix (not compatible with refseq sets)
    if norm == "ElzingaStuder" and refseq_type == "sets":
        raise ValueError("[!] norm='ElzingaStuder' requires full distance matrix. Cannot use with refseq as list of sets.")

    # check matrix_display (only used when full_matrix=True and refseq=None)
    if matrix_display not in ("full", "upper", "lower"):
        raise ValueError("[!] 'matrix_display' should be one of 'full', 'upper', or 'lower'.")

    # check indel
    # indel_type: "number", "vector", "auto"
    # must be after including missing values as an additional state (nstates)
    # all but NMS, NMSMST, SVRspell
    if isinstance(indel, (int, float)):
        indel_type = "number"
    elif isinstance(indel, (np.ndarray, list)) and np.issubdtype(indel.dtype, np.number):
        if len(indel) != nstates:
            raise ValueError("[!] When a vector, 'indel' must contain a cost for each state.")
        indel_type = "vector"
    elif indel == "auto":
        indel_type = "auto"
    else:
        raise ValueError("[!] indel")

    # check sm
    # Must be after sanity checks on 'indel'
    # Add here new seqcost() method names
    # sm.type:
    #   "none" :
    #   "matrix" : "OM", "OMloc", "OMslen", "OMspell", "OMstran", "HAM", "DHD" or "TWED".
    #   "method" : "TRATE", "CONSTANT", "INDELS", "INDELSLOG", "FUTURE", "FEATURES"
    sm_methods = ["TRATE", "CONSTANT", "INDELS", "INDELSLOG", "FUTURE", "FEATURES"]

    if sm is not None:
        if isinstance(sm, np.ndarray) and (sm.ndim == 2 or sm.ndim == 3):
            sm_type = "matrix"
        elif isinstance(sm, np.ndarray) and sm.ndim == 1:
            sm_type = "array"
        elif isinstance(sm, str):
            sm = sm.upper()
            if sm not in sm_methods:
                raise ValueError(f"[!] Invalid 'sm' value, must be one of {sm_methods}.")
            # OM with INDELS/INDELSLOG is supported (TraMineR seqdist allows it; indel from seqcost).
            sm_type = "method"
        else:
            raise ValueError("[!] 'sm' must be of a valid type (matrix, array, method).")
    else:
        sm_type = "none"

    # ===================================
    # Check Arguments Not Yet Implemented
    # ===================================
    # norm: all but  SVRspell, NMS, NMSMST (LCS and SVRspell support norm)
    if norm != "none" and method not in ["OM", "OMloc", "OMslen", "OMspell", "OMspellNew", "OMtspell", "OMstran", "TWED", "HAM", "DHD", "CHI2", "EUCLID", "LCS", "LCP", "RLCP", "LCPspell", "RLCPspell", "LCPmst", "RLCPmst", "LCPprod", "RLCPprod", "NMS", "NMSMST", "SVRspell"]:
        raise ValueError(f"[x] norm is not matched with {method}.")

    # ===============================
    # Check Method Specific Arguments
    # ===============================
    # 1. OMloc
    if method == "OMloc":
        context = kwargs.get("context", None)
        if context is None:
            # Default: context = 1 - 2 * expcost (as in R code)
            context = 1.0 - 2.0 * expcost
            print(f"[>] context set to 1 - 2 * expcost = {context}")
        if not isinstance(context, (int, float)) or context < 0:
            raise ValueError("[x] 'context' must be a number greater than or equal to 0.")
        if expcost < 0:
            raise ValueError("[x] 'expcost' must be positive for OMloc.")
        if 2 * expcost + context < 0:
            raise ValueError("[x] 'context' must be positive ('expcost' must be in [0, 0.5]).")
        print(f"[>] 2 * expcost + context = {2 * expcost + context}")
    
    # 2. OMslen
    elif method == "OMslen":
        link = kwargs.get("link", "mean")
        h = kwargs.get("h", 0.5)
        
        if link == "none":
            raise ValueError("[x] 'link' is missing for OMslen.")
        if link not in ["mean", "gmean"]:
            raise ValueError(f"[x] 'link' must be one of 'mean' or 'gmean', got '{link}'.")
        if not isinstance(h, (int, float)) or h < 0:
            raise ValueError("[x] 'h' must be a number greater than or equal to 0.")
    
    # 3. OMspell, OMspellNew, OMtspell, LCPspell, RLCPspell
    if method in ["OMspell", "OMspellNew", "OMtspell"] and expcost < 0:
        raise ValueError("[x] 'expcost' must be positive.")
    # OMtspell: switch from OMspell when tokdep_coeff is provided (TraMineR: opt.args[["tokdep.coeff"]]).
    tokdep_coeff = None
    if method == "OMspell":
        tokdep_coeff = (opts or {}).get("tokdep_coeff") or kwargs.get("tokdep_coeff")
        if tokdep_coeff is not None:
            method = "OMtspell"
    if method in ["LCPspell", "RLCPspell"] and expcost < 0:
        raise ValueError("[x] 'expcost' must be non-negative for LCPspell/RLCPspell (use 0 to ignore duration).")

    # 2. DHD
    elif method == "DHD":
        if sm_type == "method" and sm == "CONSTANT":
            raise ValueError("[!] 'sm = \"CONSTANT\"' is not relevant for DHD, consider HAM instead.")

    # TWED: nu (stiffness) and h (lambda, gap penalty) required
    elif method == "TWED":
        nu = kwargs.get("nu", None)
        h_twed = kwargs.get("h", 0.5)
        if nu is None:
            raise ValueError("[x] 'nu' is required for TWED (stiffness parameter, must be > 0).")
        if not isinstance(nu, (int, float)) or nu <= 0:
            raise ValueError("[x] 'nu' must be a number strictly greater than 0.")
        if not isinstance(h_twed, (int, float)) or h_twed < 0:
            raise ValueError("[x] 'h' must be a number greater than or equal to 0 for TWED.")

    # 3. HAM, DHD
    if method in ["HAM", "DHD"]:
        if seqs_dlens.shape[0] > 1:
            raise ValueError(f"[x] {method} is not defined for sequences of different length.")

    # ==============
    # Configure Norm
    # ==============
    if norm == "auto":
        if method in ["OM", "HAM", "DHD"]:
            norm = "maxlength"
        elif method in ["LCS", "LCP", "RLCP", "LCPmst", "RLCPmst", "LCPprod", "RLCPprod"]:
            norm = "gmean"
        elif method in ["NMS", "NMSMST", "SVRspell"]:
            norm = "YujianBo"
        elif method in ["LCPspell", "RLCPspell"]:
            # LCPspell/RLCPspell use duration-aware raw/maxdist; gmean can yield d < 0
            # because (maxdist-raw) is not bounded by 2*sqrt(n)*sqrt(m). Use maxdist.
            norm = "maxdist"
        elif method in ["OMloc", "OMslen", "OMspell", "OMspellNew", "OMtspell", "OMstran", "TWED"]:
            norm = "YujianBo"
        elif method in ["CHI2", "EUCLID"]:
            pass  # norm stays "auto" -> use normalization (divide by sqrt(n_breaks))
        else:
            raise ValueError(f"[!] No known normalization method to select automatically for {method}.")

    # For CHI2/EUCLID: norm "auto" => True, "none" => False (TraMineR norm.chi2euclid)
    norm_chi2euclid = (norm == "auto") if method in ["CHI2", "EUCLID"] else None

    if method in ["LCPspell", "RLCPspell"] and norm == "gmean":
        print("[!] Warning: norm='gmean' for LCPspell/RLCPspell can yield distances outside [0, 1]. Prefer norm='maxdist' or norm='none'. See developer/NORM_GUIDE.md.")

    # =========================================
    # CHI2 / EUCLID (C++ or Python implementation)
    # =========================================
    if method in ["CHI2", "EUCLID"]:
        from .measures_implemented_with_python.chi2_euclid import (
            build_chi2_allmat_pdotj,
            chi2_euclid_distances,
        )
        step = kwargs.get("step", 1)
        breaks = kwargs.get("breaks", None)
        overlap = kwargs.get("overlap", False)
        global_pdotj = kwargs.get("global_pdotj", None)
        seqdata_mat = seqdata.values
        alphabet = np.arange(1, nstates + 1, dtype=seqdata_mat.dtype)
        w = seqdata.weights
        if w is None or len(w) != nseqs:
            w = np.ones(nseqs, dtype=np.float64)
        else:
            w = np.asarray(w, dtype=np.float64)
        refseq_arg = None
        if refseq_type == "sets":
            refseq_arg = refseq
        elif refseq_type == "index":
            refseq_arg = refseq

        built = build_chi2_allmat_pdotj(
            seqdata_mat=seqdata_mat,
            alphabet=alphabet,
            weights=w,
            step=step,
            breaks=breaks,
            overlap=overlap,
            norm=norm_chi2euclid,
            euclid=(method == "EUCLID"),
            global_pdotj=global_pdotj,
            refseq=refseq_arg,
        )
        allmat = built["allmat"]
        pdotj = built["pdotj"]
        norm_factor = built["norm_factor"]
        refseq_id = built["refseq_id"]
        refseq_type_b = built["refseq_type"]
        n_total = built["n_total"]
        n1, n2 = built["n1"], built["n2"]

        use_cpp = False
        try:
            if c_code is not None and hasattr(c_code, "CHI2distance"):
                use_cpp = True
        except Exception:
            pass

        if use_cpp:
            chi2 = c_code.CHI2distance(allmat, pdotj, float(norm_factor), refseq_id)
            if refseq_type_b == "none":
                result = chi2.compute_all_distances()
            else:
                result = chi2.compute_refseq_distances()
        else:
            result = chi2_euclid_distances(
                seqdata_mat=seqdata_mat,
                alphabet=alphabet,
                weights=w,
                step=step,
                breaks=breaks,
                overlap=overlap,
                norm=norm_chi2euclid,
                euclid=(method == "EUCLID"),
                global_pdotj=global_pdotj,
                refseq=refseq_arg,
                full_matrix=full_matrix,
            )
            if refseq_type_b == "none" and not full_matrix:
                print("[>] Computed Successfully.")
                return result

        if refseq_type_b == "none":
            dist_matrix = pd.DataFrame(result, index=seqdata.ids, columns=seqdata.ids)
        elif refseq_type_b == "sets":
            dist_matrix = pd.DataFrame(
                result,
                index=seqdata.ids[refseq[0]],
                columns=seqdata.ids[refseq[1]],
            )
        else:
            dist_matrix = pd.Series(result, index=seqdata.ids)
        print("[>] Computed Successfully.")
        return dist_matrix

    # ======================
    # Configure sm and indel
    # ======================

    if indel_type == "auto" and sm_type == "matrix":
        indel = np.max(sm) / 2
        indel_type = "number"

    # OM, OMloc, OMspell, HAM, DHD, TWED
    if method in om_methods + ["OMloc", "HAM", "DHD", "TWED"]:
        if sm_type == "matrix":
            if method in om_methods + ["OMloc", "TWED"]:
                # TODO : checkcost()
                # Add a NaN column at the beginning and a NaN row at the top
                # This ensures that indexing starts from 1
                nan_col = np.full((sm.shape[0], 1), np.nan)
                sm = np.hstack([nan_col, sm])
                nan_row = np.full((1, sm.shape[1]), np.nan)
                sm = np.vstack([nan_row, sm])
                pass

            elif method == "HAM":
                # TODO : checkcost()
                nan_col = np.full((sm.shape[0], 1), np.nan)
                sm = np.hstack([nan_col, sm])
                nan_row = np.full((1, sm.shape[1]), np.nan)
                sm = np.vstack([nan_row, sm])
                pass

            else:
                raise ValueError(f"[x] No known 'sm' check for {method}.")

        elif sm_type == "array":
            if method == "DHD":
                # TODO : checkcost()
                pass
            else:
                raise ValueError(f"[x] 'sm' as an array is not relevant for {method}.")

        elif sm_type == "method":
            tv = False
            cost = None
            if sm in ["INDELS", "INDELSLOG"]:
                if method == "DHD":
                    tv = True
            elif sm == "TRATE":
                if method == "OM":
                    cost = 2
                elif method == "HAM":
                    cost = 2
                elif method == "DHD":
                    cost = 4
                    tv = True
            elif sm == "CONSTANT":
                if method == "HAM":
                    cost = 1
                else:
                    cost = 2
            # FUTURE and FEATURES: cval used only for missing cost if applicable; default 2
            elif sm in ["FUTURE", "FEATURES"]:
                cost = 2

            sm_kw = dict(
                method=sm,
                cval=cost,
                miss_cost=cost,
                time_varying=tv,
                weighted=weighted,
            )
            if sm == "FEATURES":
                sm_kw["state_features"] = kwargs.get("state_features")
                sm_kw["feature_weights"] = kwargs.get("feature_weights")
                sm_kw["feature_type"] = kwargs.get("feature_type")
            sm = get_substitution_cost_matrix(seqdata, **sm_kw)

            if indel_type == "auto":
                indel = sm['indel']
                indel_type = "vector" if getElementsNumber(indel) > 1 else "number"

                print(f"[>] generated an indel of type {indel_type}\n")

            sm = sm['sm']

            del cost, tv

        else:
            if method == "HAM":
                print("[>] Creating a 'sm' with a single substitution cost of 1.\n")
                sm = get_substitution_cost_matrix(seqdata,
                                                  method="CONSTANT",
                                                  cval=1,
                                                  miss_cost=1)
                if indel_type == "auto":
                    indel = sm['indel']
                    indel_type = "vector" if getElementsNumber(indel) > 1 else "number"

                sm = sm['sm']

            elif method == "DHD":
                print("[>] Creating a 'sm' with the costs derived from the transition rates.\n")
                sm = get_substitution_cost_matrix(seqdata,
                                                  method="TRATE",
                                                  cval=4, miss_cost=4, time_varying=True,
                                                  weighted=weighted)

                if indel_type == "auto":
                    indel = sm['indel']
                    indel_type = "vector" if getElementsNumber(indel) > 1 else "number"

                sm = sm['sm']

            else:
                raise ValueError("[x] 'sm' is missing.")

    elif method not in ["CHI2", "EUCLID", "LCS", "LCP", "RLCP", "LCPspell", "RLCPspell", "LCPmst", "RLCPmst", "LCPprod", "RLCPprod", "NMS", "NMSMST", "SVRspell"]:
        raise ValueError(f"[x] No known 'sm' preparation for {method}.")

    # TWED: set dummy row/col (state 0) for recurrence (TraMineR TWED uses 0 as "no previous")
    if method == "TWED":
        sm = np.asarray(sm, dtype=np.float64)
        if sm.shape[0] == nstates:
            nan_col = np.full((sm.shape[0], 1), np.nan)
            sm = np.hstack([nan_col, sm])
            nan_row = np.full((1, sm.shape[1]), np.nan)
            sm = np.vstack([nan_row, sm])
        indel_scalar = float(indel) if np.isscalar(indel) else float(np.max(indel))
        sm[0, 0] = 0.0
        sm[0, 1:] = indel_scalar
        sm[1:, 0] = indel_scalar

    # ===========================
    # Pre-Process Data (Part 1/2)
    # ===========================
    # OMstran: Transform sequences to transition states first
    if method == "OMstran":
        from .measures_implemented_with_python.omstran import create_transition_sequences, build_omstran_substitution_matrix
        
        # Get OMstran-specific parameters
        transindel = kwargs.get("transindel", "prob")  # "constant", "prob", or "subcost"
        otto = kwargs.get("otto", 0.5)  # Weight for substitution vs transition indel
        previous = kwargs.get("previous", False)  # Whether to include previous state
        add_column = kwargs.get("add_column", False)  # Whether to add an extra column
        
        if transindel not in ["constant", "prob", "subcost"]:
            raise ValueError(f"[!] 'transindel' must be one of 'constant', 'prob', or 'subcost', got '{transindel}'.")
        
        # Ensure sm is a matrix (not a method string)
        if sm_type == "method":
            # Build sm using the specified method
            # sm_result = get_substitution_cost_matrix(seqdata, method=sm, weighted=weighted)
            # sm = sm_result['sm']
            # if indel_type == "auto":
            #     indel = sm_result.get('indel', np.max(sm) / 2)
            #     if isinstance(indel, np.ndarray):
            #         indel_type = "vector"
            #     else:
            #         indel_type = "number"
            sm_type = "matrix"
        
        # Convert sm DataFrame to numpy array if needed
        if isinstance(sm, pd.DataFrame):
            sm = sm.values
        
        # Remove NaN row/column if present (from previous processing)
        if sm.shape[0] > len(seqdata.states) + 1:
            sm = sm[1:, 1:]  # Remove first row and column (null state)
        elif sm.shape[0] == len(seqdata.states) + 1:
            sm = sm[1:, 1:]  # Remove first row and column (null state)
        
        # Create transition sequences
        newseqdata_df, void_code = create_transition_sequences(seqdata, previous=previous, add_column=add_column)
        
        # Build new substitution matrix for transition states
        newsm, newindels, newalph = build_omstran_substitution_matrix(
            seqdata, newseqdata_df, sm, indel, transindel, otto, previous, void_code
        )
        
        # Create new SequenceData from transition sequences
        # SequenceData will automatically map transition strings to numeric codes
        newseqdata_df_with_ids = newseqdata_df.copy()
        if seqdata.id_col:
            newseqdata_df_with_ids.insert(0, seqdata.id_col, seqdata.ids)
        else:
            newseqdata_df_with_ids.insert(0, 'id', seqdata.ids)
        
        # Create column names for time
        time_cols = [f"T{i+1}" for i in range(newseqdata_df.shape[1])]
        newseqdata_df_with_ids.columns = [newseqdata_df_with_ids.columns[0]] + time_cols
        
        new_seqdata = SequenceData(
            data=newseqdata_df_with_ids,
            time=time_cols,
            states=newalph,
            id_col=seqdata.id_col if seqdata.id_col else 'id',
            weights=seqdata.weights
        )
        
        # Update variables for OM computation
        seqdata = new_seqdata
        sm = newsm
        indel = np.max(newindels)  # Use max indel for OM computation
        indel_type = "number"
        
        # Update nstates
        nstates = len(newalph)
        
        # Add NaN row/column to sm for C++ compatibility (1-indexed)
        nan_col = np.full((sm.shape[0], 1), np.nan)
        sm = np.hstack([nan_col, sm])
        nan_row = np.full((1, sm.shape[1]), np.nan)
        sm = np.vstack([nan_row, sm])
        
        # Change method to OM for distance computation
        method = "OM"
    
    seqdata_num = seqdata.values   # it's numpy

    if refseq_type == "sets":
        dseqs_num1 = np.unique(seqdata_num[refseq[0], :], axis=0)
        nunique1 = len(dseqs_num1)
        dseqs_num2 = np.unique(seqdata_num[refseq[1], :], axis=0)
        nunique2 = len(dseqs_num2)

        dseqs_num = np.vstack((dseqs_num1, dseqs_num2))

    else:
        dseqs_num = np.unique(seqdata_num, axis=0)

    # Check that dseqs_num does not exceed the max allowed number
    # if check_max_size:
    #     max_allowed_seq = np.floor(np.sqrt(np.iinfo(np.int32).max)) if refseq_type == "none" else np.iinfo(np.int32).max - 1
    #
    #     if refseq_type == "sets":
    #         if (np.sqrt(nunique1) * np.sqrt(nunique2)) > max_allowed_seq:
    #             raise ValueError(f"[!] Number of {nunique1} and {nunique2} unique sequences too large for max allowed distances {max_allowed_seq}.")
    #     else:
    #         if len(dseqs_num) > max_allowed_seq:
    #             raise ValueError(f"[!] {len(dseqs_num)} unique sequences exceeds max allowed of {max_allowed_seq}.")

    # =========================
    # Handle Reference Sequence
    # =========================
    if refseq_type == "sets":
        conc1 = seqconc(data=seqdata_num[refseq[0], :])
        conc2 = seqconc(data=dseqs_num1)
        # Find the position of each element in conc1 within conc2
        index_map = {value: idx for idx, value in enumerate(conc2)}
        seqdata_didxs1 = np.array([index_map[element] for element in conc1])

        conc3 = seqconc(data=seqdata_num[refseq[1], :])
        conc4 = seqconc(data=dseqs_num2)
        # Find the position of each element in conc3 within conc4
        index_map = {value: idx for idx, value in enumerate(conc4)}
        seqdata_didxs2 = np.array([index_map[element] for element in conc3])

    else:
        seqdata_series = seqconc(data=seqdata_num)
        dseqs_series = seqconc(data=dseqs_num)

        index_map = {value: idx for idx, value in enumerate(dseqs_series)}
        seqdata_didxs = np.array([index_map[element] for element in seqdata_series])

    if refseq_type != "none":
        if refseq_type == "sets":
            if method in ["OMstran"]:
                refseq_id = refseq
            else:
                refseq_id = [nunique1, nunique1 + nunique2]

        else:
            raise ValueError(f"[!] Unknown refseq type: {refseq_type}.")

        if refseq_type == "sets":
            print(f"[>] Pairwise measures between two subsets of sequences of sizes {len(refseq[0])} and {len(refseq[1])}")

    # ==============================
    # Compute Method-Specific Values
    # ==============================
    if method in ["OMspell", "OMspellNew", "OMtspell"]:
        if indel_type == "number":
            indellist = np.repeat(indel, nstates + 1)
            indel_type = "vector"
        elif indel_type == "vector":
            indellist = np.asarray(indel, dtype=np.float64)
            if len(indellist) != nstates + 1:
                indellist = np.resize(indellist, nstates + 1)
        indel = np.max(indellist)
        # OMtspell: token-dependent coefficients (TraMineR: same length as indel vector = nstates).
        if method == "OMtspell":
            tc = np.asarray(tokdep_coeff, dtype=np.float64)
            if tc.size == 0:
                raise ValueError("[!] tokdep_coeff must be a non-empty vector.")
            tc = np.atleast_1d(tc)
            if tc.size not in (nstates, nstates + 1):
                raise ValueError(
                    f"[!] tokdep_coeff must have length nstates ({nstates}) or nstates+1 ({nstates + 1}), got {tc.size}."
                )
            # C++ expects one value per state index (1..nstates); index 0 unused. Match indellist length.
            tokdeplist = np.insert(tc, 0, 1.0, axis=0) if tc.size == nstates else tc
            tokdeplist = np.asarray(tokdeplist, dtype=np.float64)
    
    # OMslen: convert number indel to vector if needed
    if method == "OMslen":
        if indel_type == "number":
            indellist = np.repeat(indel, nstates + 1)
            indel_type = "vector"
        elif indel_type == "vector":
            indellist = indel
        indel = np.max(indellist)
    
    # OM with vector indel: keep indellist for C++ (TraMineR uses state-dependent indel); use max(indel) for normalization.
    # TraMineR passes indels of length nstates and uses 0-based indexing in C (indellist[state] with state 0..nstates-1).
    # Our sequences use 1-based state codes (1..nstates). C++ accepts length alphasize-1 and uses indellist[state-1].
    om_indellist = None  # used only when method=="OM" and indel_type=="vector"
    if method == "OM" and indel_type == "vector":
        indel_vec = np.asarray(indel, dtype=np.float64)
        # Pass nstates costs so C++ uses 0-based indexing (indellist[state-1]). If seqcost returned [0, c1..c6], use indel_vec[1:].
        if len(indel_vec) > nstates:
            om_indellist = np.asarray(indel_vec[1 : nstates + 1], dtype=np.float64)
        else:
            om_indellist = np.asarray(indel_vec[:nstates], dtype=np.float64)
        indel = float(np.max(om_indellist))  # for normalization in C++

    # TWED: vector indel not supported, use max(indel) (TraMineR)
    elif method == "TWED" and indel_type == "vector":
        indel = float(np.max(indel))
        indel_type = "number"

    # OMslen
    # Build dur.mat (expanded duration matrix)
    if method == "OMslen":
        link = kwargs.get("link", "mean")
        h = kwargs.get("h", 0.5)
        
        # Get spell durations for distinct sequences (dseqs_num)
        # Similar to R code: dseqs.dur <- seqdur(dseqs.num, with.missing=with.missing)
        # We need to create a temporary SequenceData from dseqs_num
        from sequenzo.define_sequence_data import SequenceData as SD
        # TODO: seqdur 限制了传入的 sequence_data 必须是 SequenceData，是否可以让 seqdur 也接受 dataframe 和 numpy？
        time = list(range(1, len(seqdata.time) + 1))
        dseqs_num_dataframe = pd.DataFrame(dseqs_num, columns=time)
        states = list(range(1, len(seqdata.states) + 1))
        temp_seqdata = SD(dseqs_num_dataframe, states=states, time=time)
        dseqs_dur = seqdur(temp_seqdata)
        del dseqs_num_dataframe
        
        # Build dur.mat: expand durations to position level
        # Similar to R code: dur.mat[i, 1:sum(y)] <- rep(y, times = y)
        dur_mat = np.zeros_like(dseqs_num, dtype=np.float64)
        for i in range(len(dseqs_num)):
            y = dseqs_dur[i][~np.isnan(dseqs_dur[i])]
            if len(y) > 0:
                total_len = int(np.sum(y))
                if total_len > 0:
                    expanded = np.repeat(y, y.astype(int))
                    dur_mat[i, :min(len(expanded), dur_mat.shape[1])] = expanded[:min(len(expanded), dur_mat.shape[1])]
        
        # Apply h's negative exponential weight: dur.mat ^ (-1 * h)
        dur_mat = dur_mat ** (-h)
        
        # Adjust sm based on link parameter
        # Similar to R code: if (link == "mean") params[["scost"]] <- sm / 2
        if link == "mean":
            sm = sm / 2.0
        # else: link == "gmean", keep sm as is
        
        sublink = 1 if link == "mean" else 0
        
        del dseqs_dur
        del temp_seqdata
    
    # OMspell, OMtspell
    # Redefined dseqs.num
    elif method in ["OMspell", "OMspellNew", "OMtspell", "LCPspell", "RLCPspell", "NMSMST", "SVRspell"]:
        dseqs_dur = seqdur(seqdata) ** tpow  # Do not use dseqs.num

        # The position of the first occurrence of the deduplicated data (conc1) in the original data (conc2)
        conc1 = seqconc(data=dseqs_num)
        conc2 = seqconc(data=seqdata_num)
        index_map = {value: idx for idx, value in enumerate(conc2)}
        dseqs_oidxs = np.array([index_map[element] for element in conc1])

        # Can't sort! Otherwise, the actual sequence compared will not be the expected sequence

        # Get duration
        c = 1 if method in ["OMspell", "OMspellNew", "OMtspell"] else 0
        dseqs_dur = dseqs_dur[dseqs_oidxs, :] - c

        # Get DSS
        seqdata_dss = seqdss(seqdata)
        dseqs_num = seqdata_dss[dseqs_oidxs, :]

        if method in ["OMspell", "OMspellNew", "OMtspell", "LCPspell", "RLCPspell", "NMSMST", "SVRspell"]:
            _seqlength = seqlength(dseqs_num)
            # TraMineR uses original sequence length (number of time points) for OMspell/OMtspell normalization
            _orig_seqlength = np.full((dseqs_num.shape[0],), seqdata.seqdata.shape[1], dtype=np.int32)
        if method == "LCPspell":
            sign = 1
        elif method == "RLCPspell":
            sign = -1

        del dseqs_oidxs
        del c
        del seqdata_dss

    # HAM, DHD
    elif method in ["HAM", "DHD"]:
        if method == "HAM":
            # sm_type = "array"  # Not used. Should be here if it changes.
            sm = adaptSmForHAM(sm, nstates, seqdata.seqdata.shape[1])

        # Maximum possible cost of the Hamming distance
        max_cost = 0
        for i in range(np.max(seqs_dlens)):  # seqs_dlens has here only one value
            max_cost += np.max(sm[i, :, :])

    # LCP
    elif method == "LCP":
        sign = 1

    # RLCP
    elif method == "RLCP":
        sign = -1

    # LCPspell (spell-based LCP, forward)
    elif method == "LCPspell":
        sign = 1

    # RLCPspell (spell-based LCP, reverse)
    elif method == "RLCPspell":
        sign = -1

    # LCPmst, RLCPmst, LCPprod, RLCPprod (position-wise duration-aware LCP)
    elif method in ["LCPmst", "RLCPmst", "LCPprod", "RLCPprod"]:
        # Position-wise durations: default 1.0 for all positions (regular panel).
        durations = kwargs.get("durations")
        if durations is None:
            durations = np.ones_like(seqdata_num, dtype=np.float64)
        else:
            durations = np.asarray(durations, dtype=np.float64)
            if durations.shape != seqdata_num.shape:
                raise ValueError("[x] 'durations' must have shape (nseqs, ncols) matching seqdata.")
        # Map unique sequences to their duration rows (first occurrence in original data)
        conc1 = seqconc(data=dseqs_num)
        conc2 = seqconc(data=seqdata_num)
        index_map = {value: idx for idx, value in enumerate(conc2)}
        dseqs_oidxs = np.array([index_map[element] for element in conc1])
        dseqs_durpos = durations[dseqs_oidxs, :]
        _lengths_pos = seqlength(dseqs_num)
        _totaldur = dseqs_durpos.sum(axis=1).astype(np.float64)
        sign = 1 if method in ["LCPmst", "LCPprod"] else -1

    del index_map
    del seqdata_num

    # ===========================
    # Pre-Process Data (part 2/2)
    # ===========================
    # Modified dseqs.num for OMspell
    ndn = dseqs_num.shape[0]
    incl_refseq = " (including refseq)" if refseq_type == "sequence" else ""
    seq_or_spell = "spell sequences" if method in ["OMspell", "OMspellNew", "OMtspell", "LCPspell", "RLCPspell"] else "sequences"
    print(f"[>] Identified {ndn} unique {seq_or_spell}{incl_refseq}.")
    del ndn
    del seq_or_spell

    # =================
    # Compute Distances
    # =================
    # ElzingaStuder normalization is applied as post-processing, so use "none" for C++ computation
    norm_for_computation = "none" if norm == "ElzingaStuder" else norm
    norm_num = norms[1:].index(norm_for_computation)
    if isinstance(sm, pd.DataFrame):
        sm = sm.values
    
    # Ensure arrays are writable for C++ code (fixes issue on Windows Intel)
    # Some numpy operations (np.unique, np.hstack, np.vstack) may return read-only arrays
    if not dseqs_num.flags.writeable:
        dseqs_num = np.array(dseqs_num, copy=True)
    if sm is not None and not sm.flags.writeable:
        sm = np.array(sm, copy=True)
    
    lengths = seqlength(dseqs_num)
    # Ensure lengths is also writable (though seqlength should return a new array)
    if not lengths.flags.writeable:
        lengths = np.array(lengths, copy=True)

    # SVRspell: default prox (identity) and kweights (ones)
    if method == "SVRspell":
        prox = kwargs.get("prox", None)
        if prox is None:
            prox = np.eye(nstates, dtype=np.float64)
        else:
            prox = np.asarray(prox, dtype=np.float64)
        kweights_svr = kwargs.get("kweights", None)
        if kweights_svr is None:
            kweights_svr = np.ones(dseqs_num.shape[1], dtype=np.float64)
        else:
            kweights_svr = np.asarray(kweights_svr, dtype=np.float64)
            if len(kweights_svr) < dseqs_num.shape[1]:
                kw = np.zeros(dseqs_num.shape[1], dtype=np.float64)
                kw[:len(kweights_svr)] = kweights_svr
                kweights_svr = kw

    # NMS, NMSMST: kweights (default ones); NMS with prox uses NMSMSTSoftdistanceII
    if method in ["NMS", "NMSMST"]:
        kweights_nms = kwargs.get("kweights", None)
        if kweights_nms is None:
            kweights_nms = np.ones(dseqs_num.shape[1], dtype=np.float64)
        else:
            kweights_nms = np.asarray(kweights_nms, dtype=np.float64)
            if len(kweights_nms) < dseqs_num.shape[1]:
                kw = np.zeros(dseqs_num.shape[1], dtype=np.float64)
                kw[:len(kweights_nms)] = kweights_nms
                kweights_nms = kw
    # NMS with prox uses NMSMSTSoftdistanceII; NMS without prox uses NMSdistance
    prox_nms = None
    if method == "NMS":
        prox_nms = kwargs.get("prox", None)
        if prox_nms is not None:
            prox_nms = np.asarray(prox_nms, dtype=np.float64)

    # C++ already guarantees that invalid values will not be accessed
    warnings.filterwarnings("ignore", category=RuntimeWarning, message="invalid value encountered in cast")

    if refseq_type != "none":
        if len(refseq_id) == 1:
            refseq_id = [refseq_id, refseq_id]

        refseq_id = np.array(refseq_id, dtype=int)

        if method == "OM":
            indellist_arg = om_indellist if om_indellist is not None else np.array([], dtype=np.float64)
            om = c_code.OMdistance(dseqs_num,
                                    sm,
                                    indel,
                                    norm_num,
                                    lengths,
                                    refseq_id,
                                    indellist_arg)
            dist_matrix = om.compute_refseq_distances()

        elif method == "TWED":
            nu = kwargs.get("nu")
            h_twed = kwargs.get("h", 0.5)
            twed = c_code.TWEDdistance(dseqs_num, sm, float(indel), norm_num, float(nu), float(h_twed), lengths, refseq_id)
            dist_matrix = twed.compute_refseq_distances()

        elif method == "OMloc":
            context = kwargs.get("context", 1.0 - 2.0 * expcost)
            om = c_code.OMlocDistance(dseqs_num,
                                      sm,
                                      indel,
                                      norm_num,
                                      lengths,
                                      refseq_id,
                                      expcost,
                                      context)
            dist_matrix = om.compute_refseq_distances()

        elif method == "OMspell":
            om = c_code.OMspellDistance(dseqs_num,
                                         sm,
                                         indel,
                                         norm_num,
                                         refseq_id,
                                         expcost,
                                         dseqs_dur,
                                         indellist.astype(np.float64),
                                         _seqlength,
                                         _orig_seqlength)
            dist_matrix = om.compute_refseq_distances()

        elif method == "OMspellNew":
            om = c_code.OMspellNewDistance(dseqs_num,
                                            sm,
                                            indel,
                                            norm_num,
                                            refseq_id,
                                            expcost,
                                            dseqs_dur,
                                            indellist.astype(np.float64),
                                            _seqlength)
            dist_matrix = om.compute_refseq_distances()

        elif method == "OMtspell":
            om = c_code.OMtspellDistance(dseqs_num,
                                         sm,
                                         indel,
                                         norm_num,
                                         refseq_id,
                                         expcost,
                                         dseqs_dur,
                                         indellist.astype(np.float64),
                                         _seqlength,
                                         tokdeplist,
                                         _orig_seqlength)
            dist_matrix = om.compute_refseq_distances()

        elif method == "OMslen":
            om = c_code.OMslenDistance(dseqs_num,
                                       sm,
                                       indel,
                                       norm_num,
                                       refseq_id,
                                       dur_mat.astype(np.float64),
                                       indellist.astype(np.float64),
                                       sublink,
                                       lengths)
            dist_matrix = om.compute_refseq_distances()

        elif method == "HAM" or method == "DHD":
            DHD = c_code.DHDdistance(dseqs_num,
                                      sm,
                                      norm_num,
                                      max_cost,
                                      refseq_id)
            dist_matrix = DHD.compute_refseq_distances()

        elif method == "LCS":
            LCS = c_code.LCSdistance(dseqs_num,
                                     lengths,
                                     norm_num,
                                     refseq_id)
            dist_matrix = LCS.compute_refseq_distances()

        elif method == "SVRspell":
            SVRspell = c_code.SVRspellDistance(dseqs_num,
                                              dseqs_dur,
                                              _seqlength,
                                              prox,
                                              kweights_svr,
                                              norm_num,
                                              refseq_id)
            dist_matrix = SVRspell.compute_refseq_distances()

        elif method == "NMS":
            if prox_nms is not None:
                NMSprox = c_code.NMSMSTSoftdistanceII(dseqs_num,
                                                      lengths,
                                                      prox_nms,
                                                      kweights_nms,
                                                      norm_num,
                                                      refseq_id)
                dist_matrix = NMSprox.compute_refseq_distances()
            else:
                NMS = c_code.NMSdistance(dseqs_num,
                                         lengths,
                                         kweights_nms,
                                         norm_num,
                                         refseq_id)
                dist_matrix = NMS.compute_refseq_distances()

        elif method == "NMSMST":
            NMSMST = c_code.NMSMSTdistance(dseqs_num,
                                           dseqs_dur,
                                           _seqlength,
                                           kweights_nms,
                                           norm_num,
                                           refseq_id)
            dist_matrix = NMSMST.compute_refseq_distances()

        elif method == "LCP" or method == "RLCP":
            LCP = c_code.LCPdistance(dseqs_num,
                                     norm_num,
                                     sign,
                                     refseq_id)
            dist_matrix = LCP.compute_all_distances()

        elif method == "LCPspell" or method == "RLCPspell":
            LCPspell = c_code.LCPspellDistance(dseqs_num,
                                                dseqs_dur,
                                                _seqlength,
                                                norm_num,
                                                sign,
                                                refseq_id,
                                                expcost)
            dist_matrix = LCPspell.compute_refseq_distances()

        elif method in ["LCPmst", "RLCPmst", "LCPprod", "RLCPprod"]:
            LCPdur = c_code.LCPmstDistance(dseqs_num, dseqs_durpos, _lengths_pos, _totaldur, norm_num, sign, refseq_id) if method in ["LCPmst", "RLCPmst"] else c_code.LCPprodDistance(dseqs_num, dseqs_durpos, _lengths_pos, _totaldur, norm_num, sign, refseq_id)
            dist_matrix = LCPdur.compute_refseq_distances()

        dist_matrix = dist_matrix[seqdata_didxs1[:, None], seqdata_didxs2[None, :]]

        # TraMineR applies sqrt to NMS, NMSMST, SVRspell output
        if method in ["NMS", "NMSMST", "SVRspell"]:
            dist_matrix = np.sqrt(np.maximum(dist_matrix, 0.0))

        dist_matrix = pd.DataFrame(dist_matrix, index=seqdata.ids[refseq[0]], columns=seqdata.ids[refseq[1]])

    else:
        refseq_id = np.array([-1, -1])

        if method == "OM":
            indellist_arg = om_indellist if om_indellist is not None else np.array([], dtype=np.float64)
            om = c_code.OMdistance(dseqs_num,
                                    sm,
                                    indel,
                                    norm_num,
                                    lengths,
                                    refseq_id,
                                    indellist_arg)
            dist_matrix = om.compute_all_distances()

        elif method == "TWED":
            nu = kwargs.get("nu")
            h_twed = kwargs.get("h", 0.5)
            twed = c_code.TWEDdistance(dseqs_num, sm, float(indel), norm_num, float(nu), float(h_twed), lengths, refseq_id)
            dist_matrix = twed.compute_all_distances()

        elif method == "OMloc":
            context = kwargs.get("context", 1.0 - 2.0 * expcost)
            om = c_code.OMlocDistance(dseqs_num,
                                      sm,
                                      indel,
                                      norm_num,
                                      lengths,
                                      refseq_id,
                                      expcost,
                                      context)
            dist_matrix = om.compute_all_distances()

        elif method == "OMspell":
            om = c_code.OMspellDistance(dseqs_num,
                                         sm,
                                         indel,
                                         norm_num,
                                         refseq_id,
                                         expcost,
                                         dseqs_dur,
                                         indellist,
                                         _seqlength,
                                         _orig_seqlength)
            dist_matrix = om.compute_all_distances()

        elif method == "OMspellNew":
            om = c_code.OMspellNewDistance(dseqs_num,
                                            sm,
                                            indel,
                                            norm_num,
                                            refseq_id,
                                            expcost,
                                            dseqs_dur,
                                            indellist,
                                            _seqlength)
            dist_matrix = om.compute_all_distances()

        elif method == "OMtspell":
            om = c_code.OMtspellDistance(dseqs_num,
                                         sm,
                                         indel,
                                         norm_num,
                                         refseq_id,
                                         expcost,
                                         dseqs_dur,
                                         indellist,
                                         _seqlength,
                                         tokdeplist,
                                         _orig_seqlength)
            dist_matrix = om.compute_all_distances()

        elif method == "OMslen":
            om = c_code.OMslenDistance(dseqs_num,
                                       sm,
                                       indel,
                                       norm_num,
                                       refseq_id,
                                       dur_mat.astype(np.float64),
                                       indellist.astype(np.float64),
                                       sublink,
                                       lengths)
            dist_matrix = om.compute_all_distances()

        elif method == "HAM" or method == "DHD":
            DHD = c_code.DHDdistance(dseqs_num,
                                      sm,
                                      norm_num,
                                      max_cost,
                                      refseq_id)
            dist_matrix = DHD.compute_all_distances()

        elif method == "LCS":
            LCS = c_code.LCSdistance(dseqs_num,
                                     lengths,
                                     norm_num,
                                     refseq_id)
            dist_matrix = LCS.compute_all_distances()

        elif method == "SVRspell":
            SVRspell = c_code.SVRspellDistance(dseqs_num,
                                               dseqs_dur,
                                               _seqlength,
                                               prox,
                                               kweights_svr,
                                               norm_num,
                                               refseq_id)
            dist_matrix = SVRspell.compute_all_distances()

        elif method == "NMS":
            if prox_nms is not None:
                NMSprox = c_code.NMSMSTSoftdistanceII(dseqs_num,
                                                      lengths,
                                                      prox_nms,
                                                      kweights_nms,
                                                      norm_num,
                                                      refseq_id)
                dist_matrix = NMSprox.compute_all_distances()
            else:
                NMS = c_code.NMSdistance(dseqs_num,
                                         lengths,
                                         kweights_nms,
                                         norm_num,
                                         refseq_id)
                dist_matrix = NMS.compute_all_distances()

        elif method == "NMSMST":
            NMSMST = c_code.NMSMSTdistance(dseqs_num,
                                            dseqs_dur,
                                            _seqlength,
                                            kweights_nms,
                                            norm_num,
                                            refseq_id)
            dist_matrix = NMSMST.compute_all_distances()

        elif method == "LCP" or method == "RLCP":
            LCP = c_code.LCPdistance(dseqs_num,
                                     norm_num,
                                     sign,
                                     refseq_id)
            dist_matrix = LCP.compute_all_distances()

        elif method == "LCPspell" or method == "RLCPspell":
            LCPspell = c_code.LCPspellDistance(dseqs_num,
                                               dseqs_dur,
                                               _seqlength,
                                               norm_num,
                                               sign,
                                               refseq_id,
                                               expcost)
            dist_matrix = LCPspell.compute_all_distances()

        elif method in ["LCPmst", "RLCPmst", "LCPprod", "RLCPprod"]:
            LCPdur = c_code.LCPmstDistance(dseqs_num, dseqs_durpos, _lengths_pos, _totaldur, norm_num, sign, refseq_id) if method in ["LCPmst", "RLCPmst"] else c_code.LCPprodDistance(dseqs_num, dseqs_durpos, _lengths_pos, _totaldur, norm_num, sign, refseq_id)
            dist_matrix = LCPdur.compute_all_distances()

        # TraMineR applies sqrt to NMS, NMSMST, SVRspell output
        if method in ["NMS", "NMSMST", "SVRspell"]:
            dist_matrix = np.sqrt(np.maximum(dist_matrix, 0.0))

        _matrix = c_code.dist2matrix(nseqs, seqdata_didxs, dist_matrix)
        _dist2matrix = _matrix.padding_matrix()

    if full_matrix == True and refseq == None:
        dist_matrix = pd.DataFrame(_dist2matrix, index=seqdata.ids, columns=seqdata.ids)
        # Optional: show only upper or lower triangle for a cleaner display (distances unchanged)
        if matrix_display == "upper":
            # Upper triangle: keep row <= col (including diagonal); mask lower part, show as empty
            mask = np.triu(np.ones_like(dist_matrix, dtype=bool))
            dist_matrix = dist_matrix.where(mask).fillna("")
        elif matrix_display == "lower":
            # Lower triangle: keep row >= col (including diagonal); mask upper part, show as empty
            mask = np.tril(np.ones_like(dist_matrix, dtype=bool))
            dist_matrix = dist_matrix.where(mask).fillna("")

    elif full_matrix == False and refseq != None:
        print("[!] Sequenzo returned a full distance matrix because 'refseq' is not None. This is same as TraMineR.")

    elif full_matrix == False and refseq == None:
        dist_matrix = squareform(_dist2matrix)

    # Apply ElzingaStuder normalization if requested (post-processing step)
    # We apply a theoretical normalization following Elzinga & Studer (2019),
    # dividing distances by their theoretical maxima to ensure comparability across measures.
    if norm == "ElzingaStuder":
        from .__init__ import _import_c_code
        c_code = _import_c_code()
        
        if c_code is None or not hasattr(c_code, 'normalize_distance_matrix_ElzingaStuder'):
            raise RuntimeError("[!] C++ extension (c_code) is required for norm='ElzingaStuder'. "
                             "Please ensure the extension module is compiled correctly.")
        
        # Determine reference index for normalization
        normalization_reference_index = kwargs.get("normalization_reference_index", None)
        
        if normalization_reference_index is None:
            # If refseq is a single sequence index, use it; otherwise use 0
            if refseq_type == "index":
                normalization_reference_index = refseq
            else:
                normalization_reference_index = 0
        
        # Apply normalization using C++ implementation
        if isinstance(dist_matrix, pd.DataFrame):
            # Full matrix case
            normalized_array = c_code.normalize_distance_matrix_ElzingaStuder(
                dist_matrix.values,
                normalization_reference_index
            )
            dist_matrix = pd.DataFrame(normalized_array, index=dist_matrix.index, columns=dist_matrix.columns)
        elif isinstance(dist_matrix, pd.Series):
            # Single reference sequence case - convert to full matrix, normalize, then extract
            # This is a bit unusual but needed for ElzingaStuder normalization
            print("[!] Warning: ElzingaStuder normalization with refseq requires full distance matrix.")
            print("    Consider using full_matrix=True or computing full matrix first.")
            # For Series, we'd need the full matrix - skip normalization in this case
            pass
        else:
            # For dist objects or arrays, convert to array first
            if isinstance(dist_matrix, np.ndarray):
                dist_array = dist_matrix
            else:
                # scipy.spatial.distance.dist object
                dist_array = squareform(dist_matrix)
            
            normalized_array = c_code.normalize_distance_matrix_ElzingaStuder(
                dist_array,
                normalization_reference_index
            )
            
            if full_matrix == False and refseq == None:
                # Convert back to dist format
                dist_matrix = squareform(normalized_array)
            else:
                dist_matrix = normalized_array

    print("[>] Computed Successfully.")
    return dist_matrix



def adaptSmForHAM(sm, nstates, ncols):
    costs = np.tile(sm, (ncols, 1, 1))
    return costs

def getElementsNumber(x):
    if isinstance(x, pd.DataFrame):
        return x.shape[1]
    elif isinstance(x, (np.ndarray, list, tuple)):
        return x.size if isinstance(x, np.ndarray) else len(x)
    else:
        return 1


if __name__ == '__main__':
    from sequenzo import *

    start_time = time.time()

    # tracemalloc.start()

    # df = pd.read_csv("D:/college/research/QiQi/sequenzo/files/sampled_data_sets/broad_data/sampled_30000_data.csv")
    # df = pd.read_csv("D:/college/research/QiQi/sequenzo/files/orignal data/detailed_sequence_10_work_years_df.csv")

    # ===============================
    #             Sohee
    # ===============================
    # df = pd.read_csv('D:/college/research/QiQi/sequenzo/data_and_output/orignal data/sohee/sequence_data.csv')
    # time_list = list(df.columns)[1:133]
    # states = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0]
    # # states = ['A', 'B', 'C', 'D', 'E', 'F', 'G']
    # labels = ['FT+WC', 'FT+BC', 'PT+WC', 'PT+BC', 'U', 'OLF']
    # sequence_data = SequenceData(df, time=time_list, states=states, labels=labels, id_col="PID")
    # om = get_distance_matrix(sequence_data, method="OM", sm="TRATE", indel="auto")

    # om.to_csv("D:/college/research/QiQi/sequenzo/files/sequenzo_Sohee_string_OM_TRATE.csv", index=True)

    # ===============================
    #             kass
    # ===============================
    # df = pd.read_csv('D:/college/research/QiQi/sequenzo/files/orignal data/kass/wide_civil_final_df.csv')
    # time_list = list(df.columns)[1:]
    # states = ['Extensive Warfare', 'Limited Violence', 'No Violence', 'Pervasive Warfare', 'Prolonged Warfare',
    #           'Serious Violence', 'Serious Warfare', 'Sporadic Violence', 'Technological Warfare', 'Total Warfare']
    # sequence_data = SequenceData(df, time=time_list, time_type="year", states=states, id_col="COUNTRY")
    # om = get_distance_matrix(sequence_data, method="RLCP", sm="TRATE", indel="auto")


    # ===============================
    #             CO2
    # ===============================
    # df = pd.read_csv("D:/country_co2_emissions_missing.csv")
    # _time = list(df.columns)[1:]
    # states = ['Very Low', 'Low', 'Middle', 'High', 'Very High']
    # sequence_data = SequenceData(df, time=_time, id_col="country", states=states)
    # om = get_distance_matrix(sequence_data, method="OMspell", sm="TRATE", indel="auto")


    # ===============================
    #            detailed
    # ===============================
    # df = pd.read_csv("D:/college/research/QiQi/sequenzo/data_and_output/sampled_data_sets/detailed_data/sampled_1000_data.csv")
    # _time = list(df.columns)[4:]
    # states = ['data', 'data & intensive math', 'hardware', 'research', 'software', 'software & hardware', 'support & test']
    # sequence_data = SequenceData(df[['worker_id', 'C1', 'C2', 'C3', 'C4', 'C5', 'C6', 'C7', 'C8', 'C9', 'C10']],
    #                              time_type="age", time=_time, id_col="worker_id", states=states)
    # # refseq = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [142, 85]]
    # om = get_distance_matrix(sequence_data, method="OM", sm="TRATE", indel="auto")

    # ===============================
    #             broad
    # ===============================
    # df = pd.read_csv("D:/college/research/QiQi/sequenzo/data_and_output/sampled_data_sets/broad_data/sampled_1000_data.csv")
    # _time = list(df.columns)[4:]
    # states = ['Non-computing', 'Non-technical computing', 'Technical computing']
    # sequence_data = SequenceData(df[['worker_id', 'C1', 'C2', 'C3', 'C4', 'C5']],
    #                              time_type="age", time=_time, id_col="worker_id", states=states)
    # om = get_distance_matrix(sequence_data, method="DHD", sm="TRATE", indel="auto")

    # refseq = [[0, 1, 2], [99, 100]]
    # print(om)

    # snapshot = tracemalloc.take_snapshot()
    # top_stats = snapshot.statistics('lineno')
    # for stat in top_stats[:10]:
    #     print(stat)

    # print("================")
    # end_time = time.time()
    # print(f"[>] Total time: {end_time - start_time:.2f} seconds")
    # print(om)

    df = load_dataset('country_co2_emissions_global_deciles')
    time_list = list(df.columns)[1:]
    states = ['D1 (Very Low)', 'D2', 'D3', 'D4', 'D5', 'D6', 'D7', 'D8', 'D9', 'D10 (Very High)']
    sequence_data = SequenceData(df,
                                 time=time_list,
                                 id_col="country",
                                 states=states,
                                 labels=states)
    diss = get_distance_matrix(seqdata=sequence_data, method="OMstran", sm="CONSTANT", indel=1)
    diss